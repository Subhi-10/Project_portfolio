1. robot = [0, 0, 0];  % [x, y, theta]
goal = [10, 10]; 
obstacles = [3, 4; 5, 5; 8, 7];
dt = 0.1;
v = 2.5;
figure; hold on; axis equal;
plot(goal(1), goal(2), 'rx', 'LineWidth', 2);
plot(obstacles(:,1), obstacles(:,2), 'ko', 'LineWidth', 2);
xlim([-1 11]); ylim([-1 11]);
title('Simple Navigation');

while norm(robot(1:2) - goal) > 0.2
    angle_to_goal = atan2(goal(2) - robot(2), goal(1) - robot(1));
    w = 2 * (angle_to_goal - robot(3));
    for i = 1:size(obstacles, 1)
        if norm(robot(1:2) - obstacles(i,:)) < 2
            obs_angle = atan2(obstacles(i,2) - robot(2), obstacles(i,1) - robot(1));
            if abs(obs_angle - robot(3)) < pi/4
                if obs_angle > robot(3)
                    w = w - 3; % Turn left
                else
                    w = w + 3; % Turn right
                end
            end
        end
    end
    robot(3) = robot(3) + w * dt;
    robot(1) = robot(1) + v * cos(robot(3)) * dt;
    robot(2) = robot(2) + v * sin(robot(3)) * dt;
    plot(robot(1), robot(2), 'b.');
    drawnow;
    pause(dt);
end

2. % Initialize positions and parameters
robot_pose = [0, 0, 0];
goal = [10, 10];
dt = 0.1;
v = 2.5; % Linear velocity
obstacles = [5, 5; 7, 8; 4, 3];
r = 0.5; % Obstacle radius

% Setup plot
figure; hold on; grid on;
xlim([-1 12]); ylim([-1 12]);
title('Robot Navigation to Goal with Multiple Obstacle Avoidance');
xlabel('X Position'); ylabel('Y Position');
plot(goal(1), goal(2), 'rx', 'LineWidth', 2);
plot(obstacles(:,1), obstacles(:,2), 'ko', 'LineWidth', 2);

while norm(robot_pose(1:2) - goal) > 0.2
    % Calculate direction to goal
    angle_to_goal = atan2(goal(2) - robot_pose(2), goal(1) - robot_pose(1));
    error_angle = angle_to_goal - robot_pose(3);
    error_angle = atan2(sin(error_angle), cos(error_angle));
    
    % Check for obstacles
    avoid_obstacle = false;
    for obs = obstacles'
        if norm(robot_pose(1:2) - obs') < r + 0.5
            avoid_obstacle = true;
            avoid_angle = atan2(robot_pose(2) - obs(2), robot_pose(1) - obs(1));
            error_angle = error_angle + pi/4;
        end
    end
    
    % Update position and plot
    w = 2 * error_angle;
    robot_pose(3) = robot_pose(3) + w * dt;
    robot_pose(1) = robot_pose(1) + v * cos(robot_pose(3)) * dt;
    robot_pose(2) = robot_pose(2) + v * sin(robot_pose(3)) * dt;
    plot(robot_pose(1), robot_pose(2), 'b.', 'MarkerSize', 5);
    drawnow;
    pause(dt);
end

disp('Goal reached!');

3. % Parameters
trueDistance = 5;        % True distance to obstacle (meters)
sigma = 0.2;             % Standard deviation of sensor noise (meters)
n = 100;                 % Number of sensor measurements

% Generate noisy sensor measurements (Gaussian noise)
measuredDistances = trueDistance + sigma * randn(1, n);

% Plot histogram of sensor measurements
histogram(measuredDistances, 15);
xlabel('Measured Distance (m)');
ylabel('Frequency');
title('Probabilistic Range Sensor Model');

% Probabilistic sensor model (Gaussian distribution)
x = linspace(0, 10, 100);
pdf = (1/(sigma*sqrt(2*pi))) * exp(-(x - trueDistance).^2 / (2*sigma^2));

% Plot the probabilistic distribution
hold on;
plot(x, pdf * n * (10 / 15), 'r-', 'LineWidth', 2); % Scale PDF to match histogram
legend('Noisy Measurements', 'Probabilistic Model');

4. clear; clc;
x = [0; 0; 0]; P = eye(3); % State [x, y, theta] and covariance
landmark = [5; 5];         % Known landmark position
Q = 0.01 * eye(3); R = 0.1 * eye(2); % Process and measurement noise
dt = 0.1; u = [1; 0.1];    % Control inputs (linear and angular velocity)
grid_limit = 10;            % Grid limit [-10, 10]

tic; % Start timer
while toc < 30  % Loop for 30 seconds
    % Predict step with boundary checks
    x_new = x + [u(1)*cos(x(3))*dt; u(1)*sin(x(3))*dt; u(2)*dt];
    x_new(1:2) = max(min(x_new(1:2), grid_limit), -grid_limit); % Keep inside grid
    x = x_new; P = eye(3) * P * eye(3)' + Q;

    % Simulate measurement (range and bearing to the landmark)
    dx = landmark(1) - x(1); dy = landmark(2) - x(2);
    z = [sqrt(dx^2 + dy^2); atan2(dy, dx) - x(3)] + R * randn(2,1); 

    % Update step
    H = [-dx/sqrt(dx^2+dy^2), -dy/sqrt(dx^2+dy^2), 0; dy/(dx^2+dy^2), -dx/(dx^2+dy^2), -1];
    K = P * H' / (H * P * H' + R); % Kalman gain
    x = x + K * (z - [sqrt(dx^2+dy^2); atan2(dy, dx) - x(3)]); 
    P = (eye(3) - K * H) * P; 

    % Plot robot and landmark
    plot(x(1), x(2), 'bo', landmark(1), landmark(2), 'rx'); axis([-10 10 -10 10]);
    hold on; pause(0.1); 
end

5. grid_size = 20; 
map = zeros(grid_size);
map(1, :) = 1;  
map(end, :) = 1;
map(:, 1) = 1; 
map(:, end) = 1; 
map(10, 1) = 0;  
map(5:6, 5:7) = 2;
map(14:15, 8:9) = 2;
imagesc(map);
colormap([1 1 1; 0 0 0; 0.5 0.5 0.5]); 
axis equal;
xlabel('X-axis');
ylabel('Y-axis');
title('2D Indoor Environment Grid Map');
hold on;
plot(NaN, NaN, 'ks', 'MarkerSize', 10, 'MarkerFaceColor', [0 0 0]);  
plot(NaN, NaN, 'ks', 'MarkerSize', 10, 'MarkerFaceColor', [0.5 0.5 0.5]); 
legend('Wall', 'Furniture', 'Location', 'southoutside', 'Orientation', 'horizontal');
hold off;

6. rosinit;
odomSub = rossubscriber('/drone/odom', 'nav_msgs/Odometry'); 
laserSub = rossubscriber('/drone/scan', 'sensor_msgs/LaserScan'); 
pathPub = rospublisher('/drone/cmd_vel', 'geometry_msgs/Twist'); 
waypoints = [0, 0, 2; 5, 5, 2; 10, 0, 2];
currentWP = 1; 
tolerance = 0.2; 
maxSpeed = 0.5; 
obstacleThreshold = 1.0;
Kp = 1.0;
while currentWP <= size(waypoints, 1)
    odomData = receive(odomSub, 10); 
    position = odomData.Pose.Pose.Position;
    currentPos = [position.X, position.Y, position.Z];\
    targetPos = waypoints(currentWP, :);
    errorPos = targetPos - currentPos;
    distanceToWP = norm(errorPos);
    laserData = receive(laserSub, 10);
    minDistToObstacle = min(laserData.Ranges);
    if minDistToObstacle < obstacleThreshold
        disp('Obstacle detected, adjusting path...');
        velocityCmd = rosmessage('geometry_msgs/Twist');
        velocityCmd.Angular.Z = 0.5; 
        send(pathPub, velocityCmd);
        pause(1); 
    else
        if distanceToWP > tolerance
            velocityCmd = rosmessage('geometry_msgs/Twist');
            velocityCmd.Linear.X = Kp * errorPos(1);
            velocityCmd.Linear.Y = Kp * errorPos(2);
            velocityCmd.Linear.Z = Kp * errorPos(3);
            velMag = norm([velocityCmd.Linear.X, velocityCmd.Linear.Y, velocityCmd.Linear.Z]);
            if velMag > maxSpeed
                scaleFactor = maxSpeed / velMag;
                velocityCmd.Linear.X = velocityCmd.Linear.X * scaleFactor;
                velocityCmd.Linear.Y = velocityCmd.Linear.Y * scaleFactor;
                velocityCmd.Linear.Z = velocityCmd.Linear.Z * scaleFactor;
            end
            send(pathPub, velocityCmd);
        else
            disp(['Reached waypoint ', num2str(currentWP)]);
            currentWP = currentWP + 1;
        end
    end
    pause(0.1);
end
disp('Reached all waypoints.');
velocityCmd = rosmessage('geometry_msgs/Twist');
send(pathPub, velocityCmd);
rosshutdown;

7. rosinit;
laserSub = rossubscriber('/scan', 'sensor_msgs/LaserScan');
odomSub = rossubscriber('/odom', 'nav_msgs/Odometry'); 
map = load('map.mat'); 
numParticles = 500; 
minParticles = 100; 
maxParticles = 1000;
particles = initParticles(numParticles, map);
sensorNoise = 0.2; 
motionNoise = 0.1; 
resampleThreshold = 0.5; 
while true
    odomData = receive(odomSub, 10); 
    deltaPose = getOdomDelta(odomData); 
    laserData = receive(laserSub, 10); 
    ranges = laserData.Ranges; 
    particles = motionModelUpdate(particles, deltaPose, motionNoise);
    weights = sensorModelUpdate(particles, ranges, map, sensorNoise);
    weights = weights / sum(weights);
    Neff = 1 / sum(weights.^2);
    if Neff < resampleThreshold * numParticles
        particles = resampleParticles(particles, weights);
    end
    uncertainty = var(particles(:, 1:2)); 
    if uncertainty > 1.0
        numParticles = min(maxParticles, numParticles + 50);
    elseif uncertainty < 0.5 
        numParticles = max(minParticles, numParticles - 50);
    end
    estimatedPose = mean(particles, 1);
    plotParticles(particles, estimatedPose, map);
    pause(0.1);
end
rosshutdown;
%% Functions used in the AMCL algorithm
function particles = initParticles(numParticles, map)
    particles = zeros(numParticles, 3); 
    for i = 1:numParticles
        particles(i, 1) = rand() * (max(map.XData) - min(map.XData)) + min(map.XData); 
        particles(i, 2) = rand() * (max(map.YData) - min(map.YData)) + min(map.YData); 
        particles(i, 3) = rand() * 2 * pi;
    end
end
function deltaPose = getOdomDelta(odomData)
    pose = odomData.Pose.Pose.Position;
    orientation = odomData.Pose.Pose.Orientation;
    [yaw, ~, ~] = quat2angle([orientation.W, orientation.X, orientation.Y, orientation.Z]);
    deltaPose = [pose.X, pose.Y, yaw]; % Return as [x, y, theta]
end
function particles = motionModelUpdate(particles, deltaPose, motionNoise)
    for i = 1:size(particles, 1)
        noise = motionNoise * randn(1, 3);
        particles(i, 1) = particles(i, 1) + deltaPose(1) + noise(1);
        particles(i, 2) = particles(i, 2) + deltaPose(2) + noise(2);
        particles(i, 3) = particles(i, 3) + deltaPose(3) + noise(3);
    end
end
function weights = sensorModelUpdate(particles, ranges, map, sensorNoise)
    numParticles = size(particles, 1);
    weights = zeros(numParticles, 1);
    for i = 1:numParticles
        predictedRanges = simulateLaserScan(particles(i, :), map);
        weights(i) = exp(-0.5 * sum((predictedRanges - ranges).^2) / sensorNoise^2);
    end
end
function particles = resampleParticles(particles, weights)
    numParticles = size(particles, 1);
    indices = resampleSystematic(weights, numParticles);
    particles = particles(indices, :); % Resample particles
end
function plotParticles(particles, estimatedPose, map)
    figure(1); clf;
    imshow(map); hold on;
    scatter(particles(:, 1), particles(:, 2), 'r.'); 
    plot(estimatedPose(1), estimatedPose(2), 'bo', 'MarkerSize', 10); 
    drawnow;
end


8. rosinit; 
lidarSub = rossubscriber('/scan', 'sensor_msgs/LaserScan');
odomSub = rossubscriber('/odom', 'nav_msgs/Odometry'); 
cmdPub = rospublisher('/cmd_vel', 'geometry_msgs/Twist'); 
goal = [5, 5]; 
maxSpeed = 0.5;
maxTurnSpeed = 1.0; 
distanceThreshold = 0.2; 
safeDistance = 0.5; 
while true
    scanData = receive(lidarSub, 10); 
    ranges = scanData.Ranges; 
    angles = linspace(scanData.AngleMin, scanData.AngleMax, length(ranges));
    odomData = receive(odomSub, 10);
    [x, y, theta] = getPoseFromOdom(odomData);
    distanceToGoal = sqrt((goal(1) - x)^2 + (goal(2) - y)^2);
    if distanceToGoal < distanceThreshold
        disp('Goal reached!');
        sendVelocity(cmdPub, 0, 0);
        break;
    end
    [minDistance, minIndex] = min(ranges); 
    closestAngle = angles(minIndex); 
    if minDistance < safeDistance 
        turnSpeed = maxTurnSpeed * sign(closestAngle);
        sendVelocity(cmdPub, 0, turnSpeed);
    else
        angleToGoal = atan2(goal(2) - y, goal(1) - x) - theta; 
        linearSpeed = maxSpeed * (1 - exp(-distanceToGoal)); 
        turnSpeed = maxTurnSpeed * angleToGoal;
        sendVelocity(cmdPub, linearSpeed, turnSpeed); 
    end
    pause(0.1);
end
rosshutdown;
%% Helper functions
function [x, y, theta] = getPoseFromOdom(odomData)
    x = odomData.Pose.Pose.Position.X;
    y = odomData.Pose.Pose.Position.Y;
    orientation = odomData.Pose.Pose.Orientation;
    angles = quat2eul([orientation.W, orientation.X, orientation.Y, orientation.Z]);
    theta = angles(1); 
end
function sendVelocity(cmdPub, linearSpeed, angularSpeed)
    velMsg = rosmessage(cmdPub);
    velMsg.Linear.X = linearSpeed;
    velMsg.Angular.Z = angularSpeed; 
    send(cmdPub, velMsg); 
end
